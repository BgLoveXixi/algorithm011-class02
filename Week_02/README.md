# 本周总结
## 哈希表（Hash map） 
###   在python里面的实现就是dic和set
dic存储的键值对，而set是一个无重复元素的集合
### 实战题目里面，超哥讲到的“切记题目做一遍是不够的”，学了新的知识，有新的思路，会对原先的题解有新的看法。另外，可以养成收藏NB代码的习惯，做到时常温习，下笔有神！


## 树（tree）
#### 加快查询速度--->升维
#### 从链表→树：有多个next指针时；而当树中有环时称为图
#### 链表可以看做是特殊化的树（2个next指针），而树即为特殊化的图（没有环的图）
### 树的遍历
      前序遍历：根-左-右
      中序遍历：左-根-右
      后序遍历：左-右-根
### 二叉搜索树（也称为二叉排序树）
      普通（无序）的树，查找仍需遍历，复杂度还是O(N)，没有太大意义。
      定义：所有左子树节点小于根节点，而所有右子树大于根节点-->中序遍历为升序
      优势：插入和查找都是O(logN)
      查找：其实就是从根节点每次一分为二
      插入：基于查找，在它应该在的位置找不到它便插之
      创建：其实就是循环插入所有节点即可
      删除：普通叶子节点直接删除即可，特殊节点：需要找一个临近于删除节点，且比他大的节点来替换它
      当二叉树退化为链表时，需要用到平衡二叉树来加速查找
#### 树的面试题解法一般都是递归的
      在树的面试题，二叉树的遍历也可以通过维护一个栈来实现
      
      
## 堆（heap）
      定义：可以快速找到一堆数中最大或者最小值的数据结构（有二叉堆，斐波拉切堆以及严格斐波拉切堆等）
      有大顶堆，大根堆（根节点为最大），和 小顶堆，小根堆（根节点为最小）
      操作时间复杂度：find-max:O(1), delete-max:O(logN), insert(create):O(logN)或者O(1)
### 二叉堆（通过完全二叉堆实现）
      性质：1.完全二叉树；2.根节点≥子节点
      实现：一般通过数组实现（因为他是一棵完全二叉树）；索引为i的父节点：floor((i-1)/2),左孩子：2i+1，右孩子：2i+2
      插入（O(logN)）:1.先插到最后面，2.向上浮动：比根节点大则交换，直到不再大于根节点
      删除（max）(O(logN))：1.将尾部元素替换根，2.向下浮动：顶部元素小于左右儿子较大的一个则交换，直到不再小于
 注：二叉堆是堆（priority_queue）的一种常见且简单的实现，但不是最优/唯一的实现，工业上多用斐波拉切堆
      
      
      
 ## 图（graph）
 ### 图的属性和分类
      有点有边，Graph(V,E)
      V-vertex:点  1.度：入度和出度  2.点与点之间是否连通
      E-edge：边  1.有向和无向  2.权重
      有向有权图、有向无权图、无向有权图、无向无权图
### 图的算法
    DFS和BFS: 注意和树不同的是一定要有visited
    
    
## 最后再次提及：
##### 四件套：clarification，possible solutions->best(time & space)，code，test; 
##### 五毒神掌：代码多次做，不同思路不同题解；
##### 最近重复性：if、else，for loop，递归
      

