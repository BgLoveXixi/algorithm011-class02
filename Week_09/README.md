# 本周总结
## 高级动态规划  &&  字符串算法
### 高级动态规划
#### 动态规划、状态转移方程
    递归、分治或者回溯没有非A即B的关系，其实是定义一个问题的不同方面。熟悉递归模板，分治：分而治之（使用递归）
    感触：1.人肉递归低效、很累
          2.找到最近最简方法，将其拆解成可重复解决的问题
          3.数学归纳思维：只要把下一层管好，同时制定整个制度，让下一层再把下一层管好，最后整个体系就是完美的
          本质：寻找重复性 ---> 计算机指令集（简短的代码，必有重复性）
    要点：
      分治+最优子结构
      顺推形式：动态递推（从下往上递推）
    关键点：
        动态规划和递归或者分治没有本质上的区别（关键看有无最优子结构）
        拥有共性：找到重复子问题
        差异性：最优子结构、中途可以淘汰次优解
    动态规划状态转移方程 例题回顾：
        爬楼梯：使用动规，O(2^N) ---> O(n)  ( 可以写一个for循环，for i in range(2:n): dp[i] = dp[i-1] + dp[i-2]) )
        不同路径：f(x,y) = f(x-1,y) + f(x,y-1)  (二维数组)
        打家劫舍：多开一维维度：表示nums[i]偷和没偷，分别写出状态转移方程
        最小路径：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + A[i][j]
        股票买卖：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]), 今天没有持有股票
                  dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]), 今天持有股票
        
#### 高级动态规划
      复杂度来源
        1.状态拥有更多维度（二维、三维、或者更多、甚至还需要压缩）
        2.状态方程更复杂
#####  例题：最小编辑距离
      dp[i][j] = dp[i-1][j-1], if word1[i] == word2[i]
      dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1), 删除，插入，或着替换操作后中最小的一个
      
### 字符串算法
#### 字符串基础知识和引申题目
      java和python里面的string是不可变的，每改变一次其实是创建了一个新的string，在c/c++里面是可变的
      java里面==比较字符串，其实是比较地址，而不是内容
      
      例题：
          最长公共前缀：将所有单词对齐，从一个一直比较，直到有不一样的，则输出前面的公共前缀
          翻转一个字符串中的每个单词：先翻转整个字符串，再对每个单词翻转
          
### 高级字符串算法
#### 最长子串、子序列
    1.最长子序列：dp[i][j] = dp[i-1][j-1] + 1(if s1[i-1]==s2[j-1])
              else dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    2.最长子串：dp[i][j] = dp[i-1][j-1] + 1(if s1[i-1]==s2[j-1])
              else dp[i][j] = 0
#### 最长回文子串
    1.暴力：从左从右滑动，枚举所有子串，然后判断子串是否是回文串
    2.改进：回文串最左最右相同：枚举回文串中心，可以在一个字母上（此时回文串长度奇数，从中心扩散，一直到左右两边字母不同，返回最大长度），也可以是在2个字母中间，
    3.DP：定义P(i,j) = true  s[i,j]是回文串，s[i,j]表示从i到j的字符串
                     = false s[i,j]不是回文串
           P(i,j) = (P(i-1,j-1) && S[i] = S[i] == S[j])
           
#### 字符串匹配算法
    1.Rabin-Karp算法的思想：
        a.假设子串的长度为M(pat),目标字符串的长度为N(txt)
        b.计算子串的hash值hash_pat
        c.计算目标字符串txt中每个长度为M的子串的hash值（共需要计算N-M+1次）
        d.比较hash值：如果hash值不同，字符串必然不匹配；如果hash值相同，则还需要使用朴素算法再次进行判断
    2.KMP算法思想：
        当子串与目标字符串不匹配时，其实你已经知道了前面已经匹配成功那一部分的字符（包括子串和目标字符串）。以阮一峰的文章为例，当空格与D不匹配时，你其实知道前面六个字符是“ABCDAB”。KMP算法的想法是，继续把他向后移，这样提高了效率。
  http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
  https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171

